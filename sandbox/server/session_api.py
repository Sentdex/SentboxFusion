"""Session-based execution API providing stateful file persistence between calls.

The implementation re-uses the existing language runners. Files generated by one
execution round-trip via the existing `fetch_files` mechanism are cached in
memory and automatically injected into subsequent runs that reference the same
`session_id`. A simple TTL (idle timeout) is enforced lazily on every
`/execute_session` call.

Note: This is a lightweight, single-process proof-of-concept. In production you
would likely back the session store with Redis and add a background reaper.
"""

import uuid
from typing import Optional

import structlog
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field

# type: ignore for Literal alias
from sandbox.runners import CODE_RUNNERS, Language

from sandbox.server.sandbox_api import RunCodeResponse, RunStatus, RunCodeRequest, parse_run_status
from sandbox.server.session_store import SessionData, get_store


logger = structlog.stdlib.get_logger()


# Language is a Literal alias, so default to 'python'
class CreateSessionRequest(BaseModel):
    language: str = Field("python", description="Execution language")
    ttl: int = Field(1800, description="Idle timeout in seconds")


class CreateSessionResponse(BaseModel):
    session_id: str


# Override language to optional because session defines it
class ExecuteSessionRequest(RunCodeRequest):
    session_id: str = Field(..., description="ID obtained from /create_session")
    language: Optional[str] = Field(None, description="Override language for this execution")


session_router = APIRouter()

# store backend (Redis or memory)
_store = get_store()


async def _get_session_or_410(sid: str) -> SessionData:
    session = await _store.get(sid)
    if session is None:
        raise HTTPException(status_code=410, detail="Session expired or not found")
    return session


@session_router.post("/create_session", response_model=CreateSessionResponse, tags=["sessions"])
async def create_session(req: CreateSessionRequest):
    sid = uuid.uuid4().hex[:12]
    data = SessionData(language=req.language, ttl=req.ttl)
    await _store.create(sid, data)
    logger.info("session created", session_id=sid, language=req.language, ttl=req.ttl)
    return CreateSessionResponse(session_id=sid)


@session_router.post("/execute_session", response_model=RunCodeResponse, tags=["sessions"])
async def execute_session(req: ExecuteSessionRequest):
    session = await _get_session_or_410(req.session_id)
    session.touch()

    # Determine language for this call
    lang = req.language or session.language

    # Compose files: session cache overridden by request.files
    merged_files = {**session.files, **(req.files or {})}

    inner_dict = req.model_dump()
    inner_dict.pop("session_id", None)
    inner_dict["language"] = lang
    inner_dict["files"] = merged_files

    runner_req = RunCodeRequest(**inner_dict)
    from sandbox.runners.types import CodeRunArgs

    result = await CODE_RUNNERS[lang](CodeRunArgs(**runner_req.model_dump()))

    # Interpret status
    status, message = parse_run_status(result)

    # Update cached files
    session.files.update(result.files)
    session.language = lang  # remember latest runtime
    await _store.save(req.session_id, session)

    # Build response
    return RunCodeResponse(
        status=status,
        message=message,
        compile_result=result.compile_result,
        run_result=result.run_result,
        files=result.files,
    )


# Background reaper could be added via app lifespan if needed.
